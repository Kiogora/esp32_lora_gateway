/*
 / _____)             _              | |
( (____  _____ ____ _| |_ _____  ____| |__
 \____ \| ___ |    (_   _) ___ |/ ___)  _ \
 _____) ) ____| | | || |_| ____( (___| | | |
(______/|_____)_|_|_| \__)_____)\____)_| |_|
  (C)2013 Semtech-Cycleo

Description:
    Configure LoRa concentrator and record received packets in a log file

License: Revised BSD License, see LICENSE.TXT file include in the project
Maintainer: Sylvain Miermont
LoRa packet logger
===================

1. Introduction
----------------

This software is used to set up a LoRa concentrator using a JSON configuration
file and then record all the packets received in a log file, indefinitely, until
the user stops the application.
No filtering is done and all packets that are LoRa packets with the correct RF
parameters (frequency, datarate, bandwidth) should appear in the log.

2. Dependencies
----------------

This program uses the Parson library (http://kgabis.github.com/parson/) by
Krzysztof Gabis for JSON parsing.
Many thanks to him for that very practical and well written library.

This program is a typical example of LoRa concentrator HAL usage for receiving
packets.

Only high-level functions are used (the ones contained in loragw_hal) so there
is no hardware dependencies assuming the HAL is matched with the proper version
of the hardware.
Data structures of the received packets are accessed by name (ie. not at a
binary level) so new functionalities can be added to the API without affecting
that program at all.

It was tested with v1.3.0 of the libloragw library, and should be compatible
with any later version of the library assuming the API is downward-compatible.

3. Usage
---------
The only optional parameter when launching the application is the log rotation
time (in seconds).

The way the program takes configuration files into account is the following:
 * if there is a debug_conf.json parse it, others are ignored
 * if there is a global_conf.json parse it and look for the next file
 * if there is a local_conf.json parse it
If some parameters are defined in both global and local configuration files, the
local definition overwrites the global definition.

The global configuration file should be exactly the same throughout your
network, contain all global parameters (parameters for "sensor" radio channels)
and preferably default "safe" values for parameters that are specific for each
gateway (eg. specify a default MAC address).

If you have build the libloragw library for a specific radio band (eg. ETSI
868 MHz band) a ready-to-use global_conf.json file is generated by the Makefile 
with a set of channels typical for a 'LoRa MAC' network application.
If you don't specify a radio band, an empty global_conf.json is generated and
must be filled with the settings you need.

The local configuration file should contain parameters that are specific to each
gateway (eg. MAC address, frequency for backhaul radio channels).

In each configuration file, the program looks for a JSON object named
"SX1301_conf" that should contain the parameters for the LoRa concentrator board
(RF channels definition, modem parameters, etc) and another JSON object called
"gateway_conf" that should contain the gateway parameters (gateway MAC address,
IP address of the LoRa MAC controller, network authentication parameters, etc).

To learn more about the JSON configuration format, read the provided JSON files
and the API documentation. A dedicated document will be available later on.

The received packets are put in a CSV file whose name include the MAC address of
the gateway in hexadecimal format and a UTC timestamp of log starting time in
ISO 8601 recommended compact format:
yyyymmddThhmmssZ (eg. 20131009T172345Z for October 9th, 2013 at 5:23:45PM UTC)

To able continuous monitoring, the current log file is closed is closed and a
new one is opened every hour (by default, rotation interval is settable by the
user using -r command line option).
No packet is lost during that rotation of log file.
Every log file but the current one can then be modified, uploaded and/or deleted
without any consequence for the program execution.

*/


/* -------------------------------------------------------------------------- */
/* --- DEPENDANCIES --------------------------------------------------------- */

#include <stdint.h>     /* C99 types */
#include <stdbool.h>    /* bool type */
#include <stdio.h>      /* printf fprintf sprintf fopen fputs */
#include <unistd.h>     /* getopt access */

#include <string.h>     /* memset */
#include <sys/time.h>
#include <time.h>       /* time clock_gettime strftime gmtime*/

#include "parson.h"
#include "loragw_hal.h"
#include "loragw_aux.h"
#include "gsm.h"


#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/semphr.h"
#include "freertos/event_groups.h"
#include "esp_wifi.h"
#include "esp_event_loop.h"

#include <errno.h>
#include <sys/fcntl.h>
#include "nvs.h"
#include "nvs_flash.h"
#include "esp_partition.h"
#include "esp_vfs.h"
#include "esp_vfs_fat.h"
#include "esp_log.h"
#include "spiffs_vfs.h"

#include "esp_system.h"

#include "lwip/err.h"
#include "apps/sntp/sntp.h"

/* -------------------------------------------------------------------------- */
/* --- PRIVATE MACROS ------------------------------------------------------- */

#define ARRAY_SIZE(a)   (sizeof(a) / sizeof((a)[0]))

#define SPI_SPEED 8000000

#define EXAMPLE_WIFI_SSID "EED Sky"
#define EXAMPLE_WIFI_PASS "20150815"

#define JOIN_REQUEST 0x00
#define UNCONFIRMED_UP 0x40
#define CONFIRMED_UP 0x80
#define PROPRIETARY 0xE0

#define EUI_LEN 8
#define DEVADDR_LEN 4
#define FCNT_LEN 2
#define FPORT_LEN 1


/* -------------------------------------------------------------------------- */
/* --- PRIVATE VARIABLES (GLOBAL) ------------------------------------------- */

/* FreeRTOS event group to signal when we are connected & ready to make a request */
static EventGroupHandle_t wifi_event_group;

/* The event group allows multiple bits for each event,
   but we only care about one event - are we connected
   to the AP with an IP? */
const int CONNECTED_BIT = BIT0;

/* configuration variables needed by the application  */
uint8_t mac_val[8] = {0};
uint64_t mac = 0;
uint64_t lgwm = 0; /* LoRa gateway hardcoded default MAC address */
char lgwm_str[17];

/* clock and log file management */
time_t now_time;
time_t log_start_time;
FILE * log_file = NULL;
char log_file_name[64];

static const char* TAG = "[UTIL_PKT_LOGGER]";

/* -------------------------------------------------------------------------- */
/* --- PRIVATE FUNCTIONS DECLARATION ---------------------------------------- */
static void obtain_time(void);
static void initialize_sntp(void);
static void initialise_wifi(void);
static esp_err_t event_handler(void *ctx, system_event_t *event);

static void get_base_mac(uint8_t* mac_buffer);

int parse_SX1301_configuration(const char * conf_file);
int parse_gateway_configuration(const char * conf_file);
void open_log(void);

/* -------------------------------------------------------------------------- */
/* --- PRIVATE FUNCTIONS DEFINITION ----------------------------------------- */

static void obtain_time(void)
{
    ESP_ERROR_CHECK( nvs_flash_init() );
    initialise_wifi();
    xEventGroupWaitBits(wifi_event_group, CONNECTED_BIT,
                        false, true, portMAX_DELAY);
    initialize_sntp();

    // wait for time to be set
    now_time = 0;
    struct tm timeinfo = { 0 };
    int retry = 0;
    const int retry_count = 10;
    while(timeinfo.tm_year < (2018 - 1900) && ++retry < retry_count) {
        ESP_LOGI(TAG, "Waiting for system time to be set... (%d/%d)\n", retry, retry_count);
        vTaskDelay(2000 / portTICK_PERIOD_MS);
        time(&now_time);
        localtime_r(&now_time, &timeinfo);
    }

    ESP_ERROR_CHECK( esp_wifi_stop() );
}

static void initialize_sntp(void)
{
    ESP_LOGI(TAG, "Initializing SNTP\n");
    sntp_setoperatingmode(SNTP_OPMODE_POLL);
    sntp_setservername(0, "pool.ntp.org");
    sntp_init();
}

static void initialise_wifi(void)
{
    tcpip_adapter_init();
    wifi_event_group = xEventGroupCreate();
    ESP_ERROR_CHECK( esp_event_loop_init(event_handler, NULL) );
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK( esp_wifi_init(&cfg) );
    ESP_ERROR_CHECK( esp_wifi_set_storage(WIFI_STORAGE_RAM) );
    wifi_config_t wifi_config = {
        .sta = {
            .ssid = EXAMPLE_WIFI_SSID,
            .password = EXAMPLE_WIFI_PASS,
        },
    };
    ESP_LOGI(TAG, "Setting WiFi configuration SSID %s...\n", wifi_config.sta.ssid);
    ESP_ERROR_CHECK( esp_wifi_set_mode(WIFI_MODE_STA) );
    ESP_ERROR_CHECK( esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config) );
    ESP_ERROR_CHECK( esp_wifi_start() );
}

static esp_err_t event_handler(void *ctx, system_event_t *event)
{
    switch(event->event_id) {
    case SYSTEM_EVENT_STA_START:
        esp_wifi_connect();
        break;
    case SYSTEM_EVENT_STA_GOT_IP:
        xEventGroupSetBits(wifi_event_group, CONNECTED_BIT);
        break;
    case SYSTEM_EVENT_STA_DISCONNECTED:
        /* This is a workarpayloadound as ESP32 WiFi libs don't currently
           auto-reassociate. */
        esp_wifi_connect();
        xEventGroupClearBits(wifi_event_group, CONNECTED_BIT);
        break;
    default:
        break;
    }
    return ESP_OK;
}

static void get_base_mac(uint8_t* mac_buffer)
{
    uint64_t temp_mac = 0;
    if(mac_buffer != NULL)
    {
        if(esp_efuse_mac_get_default(mac_buffer) == ESP_OK)
        {

            ESP_LOGI(TAG, "SUCCESSFULLY READ BASE_MAC FROM EFUSE!\n");
            for(int i=0; i<8; i++)
            {
                temp_mac = mac_buffer[i];
                mac |= (temp_mac << (7-i)*8);
            }
             ESP_LOGI(TAG, "INFO: Actual gateway MAC address is configured to 0x%016llX\n", mac);
        }
        else
        {
            ESP_LOGE(TAG, "UNSUCCESSFUL IN READING BASE_MAC FROM EFUSE!\n");
        }
    }
}

int parse_SX1301_configuration(const char * conf_file) {
    int i;
    const char conf_obj[] = "SX1301_conf_rak831";
    char param_name[32]; /* used to generate variable parameter names */
    const char *str; /* used to store string value from JSON object */
    struct lgw_conf_board_s boardconf;
    struct lgw_conf_rxrf_s rfconf;
    struct lgw_conf_rxif_s ifconf;
    JSON_Value *root_val;
    JSON_Object *root = NULL;
    JSON_Object *conf = NULL;
    JSON_Value *val;
    uint32_t sf, bw;

    /* try to parse JSON */
    root_val = json_parse_file_with_comments(conf_file);
    root = json_value_get_object(root_val);
    if (root == NULL) {
        ESP_LOGE(TAG, "ERROR: %s id not a valid JSON file\n", conf_file);
        exit(EXIT_FAILURE);
    }
    conf = json_object_get_object(root, conf_obj);
    if (conf == NULL) {
        ESP_LOGI(TAG, "INFO: %s does not contain a JSON object named %s\n", conf_file, conf_obj);
        return -1;
    } else {
        ESP_LOGI(TAG, "INFO: %s does contain a JSON object named %s, parsing SX1301 parameters\n", conf_file, conf_obj);
    }

    /* set board configuration */
    memset(&boardconf, 0, sizeof boardconf); /* initialize configuration structure */
    val = json_object_get_value(conf, "lorawan_public"); /* fetch value (if possible) */
    if (json_value_get_type(val) == JSONBoolean) {
        boardconf.lorawan_public = (bool)json_value_get_boolean(val);
    } else {
        ESP_LOGW(TAG, "WARNING: Data type for lorawan_public seems wrong, please check\n");
        boardconf.lorawan_public = false;
    }
    val = json_object_get_value(conf, "clksrc"); /* fetch value (if possible) */
    if (json_value_get_type(val) == JSONNumber) {
        boardconf.clksrc = (uint8_t)json_value_get_number(val);
    } else {
        ESP_LOGW(TAG, "WARNING: Data type for clksrc seems wrong, please check\n");
        boardconf.clksrc = 0;
    }
    ESP_LOGI(TAG, "INFO: lorawan_public %d, clksrc %d\n", boardconf.lorawan_public, boardconf.clksrc);
    /* all parameters parsed, submitting configuration to the HAL */
    if (lgw_board_setconf(boardconf) != LGW_HAL_SUCCESS) {
        ESP_LOGE(TAG, "ERROR: Failed to configure board\n");
        return -1;
    }

    /* set configuration for RF chains */
    for (i = 0; i < LGW_RF_CHAIN_NB; ++i) {
        memset(&rfconf, 0, sizeof(rfconf)); /* initialize configuration structure */
        sprintf(param_name, "radio_%i", i); /* compose parameter path inside JSON structure */
        val = json_object_get_value(conf, param_name); /* fetch value (if possible) */
        if (json_value_get_type(val) != JSONObject) {
            ESP_LOGI(TAG, "INFO: no configuration for radio %i\n", i);
            continue;
        }
        /* there is an object to configure that radio, let's parse it */
        sprintf(param_name, "radio_%i.enable", i);
        val = json_object_dotget_value(conf, param_name);
        if (json_value_get_type(val) == JSONBoolean) {
            rfconf.enable = (bool)json_value_get_boolean(val);
        } else {
            rfconf.enable = false;
        }
        if (rfconf.enable == false) { /* radio disabled, nothing else to parse */
            ESP_LOGI(TAG, "INFO: radio %i disabled\n", i);
        } else  { /* radio enabled, will parse the other parameters */
            snprintf(param_name, sizeof param_name, "radio_%i.freq", i);
            rfconf.freq_hz = (uint32_t)json_object_dotget_number(conf, param_name);
            snprintf(param_name, sizeof param_name, "radio_%i.rssi_offset", i);
            rfconf.rssi_offset = (float)json_object_dotget_number(conf, param_name);
            snprintf(param_name, sizeof param_name, "radio_%i.type", i);
            str = json_object_dotget_string(conf, param_name);
            if (!strncmp(str, "SX1255", 6)) {
                rfconf.type = LGW_RADIO_TYPE_SX1255;
            } else if (!strncmp(str, "SX1257", 6)) {
                rfconf.type = LGW_RADIO_TYPE_SX1257;
            } else {
                ESP_LOGW(TAG, "WARNING: invalid radio type: %s (should be SX1255 or SX1257)\n", str);
            }
            snprintf(param_name, sizeof param_name, "radio_%i.tx_enable", i);
            val = json_object_dotget_value(conf, param_name);
            if (json_value_get_type(val) == JSONBoolean) {
                rfconf.tx_enable = (bool)json_value_get_boolean(val);
                if (rfconf.tx_enable == true) {
                    /* tx notch filter frequency to be set */
                    snprintf(param_name, sizeof param_name, "radio_%i.tx_notch_freq", i);
                    rfconf.tx_notch_freq = (uint32_t)json_object_dotget_number(conf, param_name);
                }
            } else {
                rfconf.tx_enable = false;
            }
            ESP_LOGI(TAG, "INFO: radio %i enabled (type %s), center frequency %u, RSSI offset %f, tx enabled %d, tx_notch_freq %u\n", i, str, rfconf.freq_hz, rfconf.rssi_offset, rfconf.tx_enable, rfconf.tx_notch_freq);
        }
        /* all parameters parsed, submitting configuration to the HAL */
        if (lgw_rxrf_setconf(i, rfconf) != LGW_HAL_SUCCESS) {
            ESP_LOGE(TAG, "ERROR: invalid configuration for radio %i\n", i);
            return -1;
        }
    }

    /* set configuration for LoRa multi-SF channels (bandwidth cannot be set) */
    for (i = 0; i < LGW_MULTI_NB; ++i) {
        memset(&ifconf, 0, sizeof(ifconf)); /* initialize configuration structure */
        sprintf(param_name, "chan_multiSF_%i", i); /* compose parameter path inside JSON structure */
        val = json_object_get_value(conf, param_name); /* fetch value (if possible) */
        if (json_value_get_type(val) != JSONObject) {
            ESP_LOGI(TAG, "INFO: no configuration for LoRa multi-SF channel %i\n", i);
            continue;
        }
        /* there is an object to configure that LoRa multi-SF channel, let's parse it */
        sprintf(param_name, "chan_multiSF_%i.enable", i);
        val = json_object_dotget_value(conf, param_name);
        if (json_value_get_type(val) == JSONBoolean) {
            ifconf.enable = (bool)json_value_get_boolean(val);
        } else {
            ifconf.enable = false;
        }
        if (ifconf.enable == false) { /* LoRa multi-SF channel disabled, nothing else to parse */
            ESP_LOGI(TAG, "INFO: LoRa multi-SF channel %i disabled\n", i);
        } else  { /* LoRa multi-SF channel enabled, will parse the other parameters */
            sprintf(param_name, "chan_multiSF_%i.radio", i);
            ifconf.rf_chain = (uint32_t)json_object_dotget_number(conf, param_name);
            sprintf(param_name, "chan_multiSF_%i.if", i);
            ifconf.freq_hz = (int32_t)json_object_dotget_number(conf, param_name);
            // TODO: handle individual SF enabling and disabling (spread_factor)
            ESP_LOGI(TAG, "INFO: LoRa multi-SF channel %i enabled, radio %i selected, IF %i Hz, 125 kHz bandwidth, SF 7 to 12\n", i, ifconf.rf_chain, ifconf.freq_hz);
        }
        /* all parameters parsed, submitting configuration to the HAL */
        if (lgw_rxif_setconf(i, ifconf) != LGW_HAL_SUCCESS) {
            ESP_LOGE(TAG, "ERROR: invalid configuration for Lora multi-SF channel %i\n", i);
            return -1;
        }
    }

    /* set configuration for LoRa standard channel */
    memset(&ifconf, 0, sizeof(ifconf)); /* initialize configuration structure */
    val = json_object_get_value(conf, "chan_Lora_std"); /* fetch value (if possible) */
    if (json_value_get_type(val) != JSONObject) {
        ESP_LOGI(TAG, "INFO: no configuration for LoRa standard channel\n");
    } else {
        val = json_object_dotget_value(conf, "chan_Lora_std.enable");
        if (json_value_get_type(val) == JSONBoolean) {
            ifconf.enable = (bool)json_value_get_boolean(val);
        } else {
            ifconf.enable = false;
        }
        if (ifconf.enable == false) {
            ESP_LOGI(TAG, "INFO: LoRa standard channel %i disabled\n", i);
        } else  {
            ifconf.rf_chain = (uint32_t)json_object_dotget_number(conf, "chan_Lora_std.radio");
            ifconf.freq_hz = (int32_t)json_object_dotget_number(conf, "chan_Lora_std.if");
            bw = (uint32_t)json_object_dotget_number(conf, "chan_Lora_std.bandwidth");
            switch(bw) {
                case 500000: ifconf.bandwidth = BW_500KHZ; break;
                case 250000: ifconf.bandwidth = BW_250KHZ; break;
                case 125000: ifconf.bandwidth = BW_125KHZ; break;
                default: ifconf.bandwidth = BW_UNDEFINED;
            }
            sf = (uint32_t)json_object_dotget_number(conf, "chan_Lora_std.spread_factor");
            switch(sf) {
                case  7: ifconf.datarate = DR_LORA_SF7;  break;
                case  8: ifconf.datarate = DR_LORA_SF8;  break;
                case  9: ifconf.datarate = DR_LORA_SF9;  break;
                case 10: ifconf.datarate = DR_LORA_SF10; break;
                case 11: ifconf.datarate = DR_LORA_SF11; break;
                case 12: ifconf.datarate = DR_LORA_SF12; break;
                default: ifconf.datarate = DR_UNDEFINED;
            }
            ESP_LOGI(TAG, "INFO: LoRa standard channel enabled, radio %i selected, IF %i Hz, %u Hz bandwidth, SF %u\n", ifconf.rf_chain, ifconf.freq_hz, bw, sf);
        }
        if (lgw_rxif_setconf(8, ifconf) != LGW_HAL_SUCCESS) {
            ESP_LOGE(TAG, "ERROR: invalid configuration for Lora standard channel\n");
            return -1;
        }
    }

    /* set configuration for FSK channel */
    memset(&ifconf, 0, sizeof(ifconf)); /* initialize configuration structure */
    val = json_object_get_value(conf, "chan_FSK"); /* fetch value (if possible) */
    if (json_value_get_type(val) != JSONObject) {
        ESP_LOGI(TAG, "INFO: no configuration for FSK channel\n");
    } else {
        val = json_object_dotget_value(conf, "chan_FSK.enable");
        if (json_value_get_type(val) == JSONBoolean) {
            ifconf.enable = (bool)json_value_get_boolean(val);
        } else {
            ifconf.enable = false;
        }
        if (ifconf.enable == false) {
            ESP_LOGI(TAG, "INFO: FSK channel %i disabled\n", i);
        } else  {
            ifconf.rf_chain = (uint32_t)json_object_dotget_number(conf, "chan_FSK.radio");
            ifconf.freq_hz = (int32_t)json_object_dotget_number(conf, "chan_FSK.if");
            bw = (uint32_t)json_object_dotget_number(conf, "chan_FSK.bandwidth");
            if      (bw <= 7800)   ifconf.bandwidth = BW_7K8HZ;
            else if (bw <= 15600)  ifconf.bandwidth = BW_15K6HZ;
            else if (bw <= 31200)  ifconf.bandwidth = BW_31K2HZ;
            else if (bw <= 62500)  ifconf.bandwidth = BW_62K5HZ;
            else if (bw <= 125000) ifconf.bandwidth = BW_125KHZ;
            else if (bw <= 250000) ifconf.bandwidth = BW_250KHZ;
            else if (bw <= 500000) ifconf.bandwidth = BW_500KHZ;
            else ifconf.bandwidth = BW_UNDEFINED;
            ifconf.datarate = (uint32_t)json_object_dotget_number(conf, "chan_FSK.datarate");
            ESP_LOGI(TAG, "INFO: FSK channel enabled, radio %i selected, IF %i Hz, %u Hz bandwidth, %u bps datarate\n", ifconf.rf_chain, ifconf.freq_hz, bw, ifconf.datarate);
        }
        if (lgw_rxif_setconf(9, ifconf) != LGW_HAL_SUCCESS) {
            ESP_LOGE(TAG, "ERROR: invalid configuration for FSK channel\n");
            return -1;
        }
    }
    json_value_free(root_val);
    return 0;
}

int parse_gateway_configuration(const char * conf_file) {
    const char conf_obj[] = "gateway_conf";
    JSON_Value *root_val;
    JSON_Object *root = NULL;
    JSON_Object *conf = NULL;
    const char *str; /* pointer to sub-strings in the JSON data */
    unsigned long long ull = 0;

    /* try to parse JSON */
    root_val = json_parse_file_with_comments(conf_file);
    root = json_value_get_object(root_val);
    if (root == NULL) {
        ESP_LOGE(TAG, "ERROR: %s id not a valid JSON file\n", conf_file);
        exit(EXIT_FAILURE);
    }
    conf = json_object_get_object(root, conf_obj);
    if (conf == NULL) {
        ESP_LOGI(TAG, "INFO: %s does not contain a JSON object named %s\n", conf_file, conf_obj);
        return -1;
    } else {
        ESP_LOGI(TAG, "INFO: %s does contain a JSON object named %s, parsing gateway parameters\n", conf_file, conf_obj);
    }

    /* getting network parameters (only those necessary for the packet logger) */
    str = json_object_get_string(conf, "gateway_ID");
    if (str != NULL) {
        sscanf(str, "%llx", &ull);
        lgwm = ull;
        ESP_LOGI(TAG, "INFO: Hardcoded gateway MAC address read is %016llX...shall be overridden by dynamic mac\n", ull);
    }

    json_value_free(root_val);
    return 0;
}

void open_log(void)
{
    int i;
    char iso_date[20];

    strftime(iso_date,ARRAY_SIZE(iso_date),"%Y%m%dT%H%M%SZ",gmtime(&now_time)); /* format yyyymmddThhmmssZ */
    log_start_time = now_time; /* keep track of when the log was started, for log rotation */

    sprintf(log_file_name, "/spiffs/pktlog_%s_%s.csv", lgwm_str, iso_date);
    log_file = fopen(log_file_name, "a"); /* create log file, append if file already exist */
    if (log_file == NULL) {
        ESP_LOGI(TAG, "ERROR: impossible to create log file %s\n", log_file_name);
        exit(EXIT_FAILURE);
    }

    i = fprintf(log_file, "\"gateway ID\",\"UTC timestamp\",\"us count\",\"frequency\",\"RF chain\",\"RX chain\",\"status\",\"size\",\"modulation\",\"bandwidth\",\"datarate\",\"coderate\",\"RSSI\",\"SNR\",\"PHY payload\",\"MAC message type\",\"APP-EUI\",\"DEV-EUI\",\"devaddr\",\"ADR bit\",\"Foptlen\",\"FCnt\",\"Fport\",\"MAC payload content\"\n");
    if (i < 0) {
        ESP_LOGE(TAG, "ERROR: impossible to write to log file %s\n", log_file_name);
        exit(EXIT_FAILURE);
    }

    ESP_LOGI(TAG, "INFO: Now writing to log file %s\n", log_file_name);
    return;
}

void  app_main(void)
{
    int i, j; /* loop and temporary variables */
    int sleep_time = 3; /* 3 ms */

    /* clock and log rotation management */
    int log_rotate_interval = 72000; /* by default, rotation every hour */
    int time_check = 0; /* variable used to limit the number of calls to time() function */
    unsigned long pkt_in_log = 0; /* count the number of packet written in each log file */
    int byte_count = 0; //byte count
    
    /* configuration file related */
    const char global_conf_fname[] = "/spiffs/global_conf.json"; /* contain global (typ. network-wide) configuration */
    const char local_conf_fname[] = "/spiffs/local_conf.json"; /* contain node specific configuration, overwrite global parameters for parameters that are defined in both */
    const char debug_conf_fname[] = "/spiffs/debug_conf.json"; /* if present, all other configuration files are ignored */

    /* allocate memory for packet fetching and processing */
    struct lgw_pkt_rx_s rxpkt[16]; /* array containing up to 16 inbound packets metadata */
    struct lgw_pkt_rx_s *p; /* pointer on a RX packet */
    int nb_pkt;

    /* local timestamp variables until we get accurate GPS time */
    struct timeval fetch_time;
    //struct timespec fetchtime;
    char fetch_timestamp[30];
    struct tm * x;
    struct tm timeinfo;

    time(&now_time);
    localtime_r(&now_time, &timeinfo);
    // Is time set? If not, tm_year will be (1970 - 1900).
    if (timeinfo.tm_year < (2018 - 1900)) {
        ESP_LOGI(TAG, "Time is not set yet. Connecting to WiFi and getting time over NTP.");
        obtain_time();
        // update 'now' variable with current time
        time(&now_time);
    }
    char strftime_buf[64];

    // Set timezone to Africa/Nairobi and print local time
    setenv("TZ", "EAT-3", 1);
    tzset();
    localtime_r(&now_time, &timeinfo);
    strftime(strftime_buf, sizeof(strftime_buf), "%c", &timeinfo);
    ESP_LOGI(TAG, "The current date/time in Nairobi is: %s", strftime_buf);

    ESP_LOGI(TAG, "====MOUNTING SPIFFS====");
    vfs_spiffs_register();
    if (spiffs_is_mounted)
    {
        get_base_mac(mac_val);
        FILE* fp=fopen(debug_conf_fname, "r");
        FILE* fp1=fopen(global_conf_fname, "r");
        FILE* fp2=fopen(local_conf_fname, "r");
        /* configuration files management */
        if (fp != NULL) {
        /* if there is a debug conf, parse only the debug conf */
            fclose(fp);
            fclose(fp1);
            fclose(fp2);
            ESP_LOGI(TAG, "INFO: found debug configuration file %s, other configuration files will be ignored\n", debug_conf_fname);
            parse_SX1301_configuration(debug_conf_fname);
            parse_gateway_configuration(debug_conf_fname);
        }
        else if (fp1 != NULL)
        {
            fclose(fp);
            fclose(fp1);
        /* if there is a global conf, parse it and then try to parse local conf  */
            ESP_LOGI(TAG, "INFO: found global configuration file %s, trying to parse it\n", global_conf_fname);
            parse_SX1301_configuration(global_conf_fname);
            parse_gateway_configuration(global_conf_fname);
            if (fp2 != NULL)
            {
                ESP_LOGI(TAG, "INFO: found local configuration file %s, trying to parse it\n", local_conf_fname);
                parse_SX1301_configuration(local_conf_fname);
                parse_gateway_configuration(local_conf_fname);
            }
        } else if (fp2 != NULL) {
            fclose(fp);
            fclose(fp1);
            fclose(fp2);
        /* if there is only a local conf, parse it and that's all */
            ESP_LOGI(TAG, "INFO: found local configuration file %s, trying to parse it\n", local_conf_fname);
            parse_SX1301_configuration(local_conf_fname);
            parse_gateway_configuration(local_conf_fname);
        } else {
            ESP_LOGI(TAG, "ERROR: failed to find any configuration file named %s, %s or %s\n", global_conf_fname, local_conf_fname, debug_conf_fname);
            return;
        }

        /* starting the concentrator */
        i = lgw_start(SPI_SPEED);
        if (i == LGW_HAL_SUCCESS) {
            ESP_LOGI(TAG, "INFO: concentrator started, packet can now be received\n");
        } else {
            ESP_LOGE(TAG, "ERROR: failed to start the concentrator\n");
            return;
        }

        /* transform the MAC address into a string */
        //sprintf(lgwm_str, "%08X%08X", (uint32_t)(lgwm >> 32), (uint32_t)(lgwm & 0xFFFFFFFF));
        sprintf(lgwm_str, "%08X%08X", (uint32_t)(mac >> 32), (uint32_t)(mac & 0xFFFFFFFF));
        /* opening log file and writing CSV header*/
        time(&now_time);
        open_log();
        /* main loop */
        while (1) {
            /* fetch packets */
            nb_pkt = lgw_receive(ARRAY_SIZE(rxpkt), rxpkt);
            if (nb_pkt == LGW_HAL_ERROR) {
                ESP_LOGE(TAG, "ERROR: failed packet fetch, exiting\n");
                return;
            } else if (nb_pkt == 0) {
                wait_ms(sleep_time);
            } else {
                /* local timestamp generation until we get accurate GPS time */
                gettimeofday(&fetch_time, NULL);
                //clock_gettime(CLOCK_REALTIME, &fetch_time);
                x = gmtime(&(fetch_time.tv_sec));
                sprintf(fetch_timestamp,"%04i-%02i-%02i %02i:%02i:%02i.%03liZ",(x->tm_year)+1900,(x->tm_mon)+1,x->tm_mday,x->tm_hour,x->tm_min,x->tm_sec,(fetch_time.tv_usec)/1000); /* ISO 8601 format */
            }

            /* log packets */
            for (i=0; i < nb_pkt; ++i) {
                p = &rxpkt[i];

                if(p->status == STAT_CRC_OK)
                {
                    /* writing gateway ID */
                    //fprintf(log_file, "\"%08X%08X\",", (uint32_t)(lgwm >> 32), (uint32_t)(lgwm & 0xFFFFFFFF));
                    fprintf(log_file, "\"%08X%08X\",", (uint32_t)(mac >> 32), (uint32_t)(mac & 0xFFFFFFFF));

                    /* writing UTC timestamp*/
                    fprintf(log_file, "\"%s\",", fetch_timestamp);
                    // TODO: replace with GPS time when available

                    /* writing internal clock */
                    fprintf(log_file, "%10u,", p->count_us);

                    /* writing RX frequency */
                    fprintf(log_file, "%10u,", p->freq_hz);

                    /* writing RF chain */
                    fprintf(log_file, "%u,", p->rf_chain);

                    /* writing RX modem/IF chain */
                    fprintf(log_file, "%2d,", p->if_chain);

                    /* writing status */
                    switch(p->status) {
                        case STAT_CRC_OK:       fputs("\"CRC_OK\" ,", log_file); break;
                        case STAT_CRC_BAD:      fputs("\"CRC_BAD\",", log_file); break;
                        case STAT_NO_CRC:       fputs("\"NO_CRC\" ,", log_file); break;
                        case STAT_UNDEFINED:    fputs("\"UNDEF\"  ,", log_file); break;
                        default:                fputs("\"ERR\"    ,", log_file);
                    }

                    /* writing payload size */
                    fprintf(log_file, "%3u,", p->size);

                    /* writing modulation */
                    switch(p->modulation) {
                        case MOD_LORA:  fputs("\"LORA\",", log_file); break;
                        case MOD_FSK:   fputs("\"FSK\" ,", log_file); break;
                        default:        fputs("\"ERR\" ,", log_file);
                    }

                    /* writing bandwidth */
                    switch(p->bandwidth) {
                        case BW_500KHZ:     fputs("500000,", log_file); break;
                        case BW_250KHZ:     fputs("250000,", log_file); break;
                        case BW_125KHZ:     fputs("125000,", log_file); break;
                        case BW_62K5HZ:     fputs("62500 ,", log_file); break;
                        case BW_31K2HZ:     fputs("31200 ,", log_file); break;
                        case BW_15K6HZ:     fputs("15600 ,", log_file); break;
                        case BW_7K8HZ:      fputs("7800  ,", log_file); break;
                        case BW_UNDEFINED:  fputs("0     ,", log_file); break;
                        default:            fputs("-1    ,", log_file);
                    }

                    /* writing datarate */
                    if (p->modulation == MOD_LORA) {
                        switch (p->datarate) {
                            case DR_LORA_SF7:   fputs("\"SF7\"   ,", log_file); break;
                            case DR_LORA_SF8:   fputs("\"SF8\"   ,", log_file); break;
                            case DR_LORA_SF9:   fputs("\"SF9\"   ,", log_file); break;
                            case DR_LORA_SF10:  fputs("\"SF10\"  ,", log_file); break;
                            case DR_LORA_SF11:  fputs("\"SF11\"  ,", log_file); break;
                            case DR_LORA_SF12:  fputs("\"SF12\"  ,", log_file); break;
                            default:            fputs("\"ERR\"   ,", log_file);
                        }
                    } else if (p->modulation == MOD_FSK) {
                        fprintf(log_file, "\"%6u\",", p->datarate);
                    } else {
                        fputs("\"ERR\"   ,", log_file);
                    }

                    /* writing coderate */
                    switch (p->coderate) {
                        case CR_LORA_4_5:   fputs("\"4/5\",", log_file); break;
                        case CR_LORA_4_6:   fputs("\"2/3\",", log_file); break;
                        case CR_LORA_4_7:   fputs("\"4/7\",", log_file); break;
                        case CR_LORA_4_8:   fputs("\"1/2\",", log_file); break;
                        case CR_UNDEFINED:  fputs("\"\"   ,", log_file); break;
                        default:            fputs("\"ERR\",", log_file);
                    }

                    /* writing packet RSSI */
                    fprintf(log_file, "%+.0f,", p->rssi);

                    /* writing packet average SNR */
                    fprintf(log_file, "%+5.1f,", p->snr);

                    /* writing to log file in little endian as on the wire, hex-encoded payload (bundled in 32-bit words) */
                    fputs("\"", log_file);
                    for (j = 0; j < p->size; ++j) {
                        if ((j > 0) && (j%4 == 0)) fputs("-", log_file);
                        fprintf(log_file, "%02X", p->payload[j]);
                    }
                    fputs("\",", log_file);

                    if(p->status==STAT_CRC_OK)
                    {

                        //MAC Message type
                        switch (p->payload[0])
                        {
                            case JOIN_REQUEST:   fputs("\"Join request\",", log_file); break;
                            case UNCONFIRMED_UP:   fputs("\"Unconfirmed uplink\",", log_file); break;
                            case CONFIRMED_UP:   fputs("\"Confirmed uplink\",", log_file); break;
                            case PROPRIETARY:   fputs("\"Proprietary\",", log_file); break;
                        }

                        if(p->payload[0]==JOIN_REQUEST)
                        {
                            //AppEUI
                            fputs("\"", log_file);
                            for(byte_count=0;byte_count<EUI_LEN;byte_count++)
                            {
                                fprintf(log_file, "%02X", p->payload[8-byte_count]);
                            }
                            fputs("\",", log_file);
                            
                            //DevEUI
                            fputs("\"", log_file);    
                            for(byte_count=0;byte_count<EUI_LEN;byte_count++)
                            {
                                fprintf(log_file, "%02X", p->payload[16-byte_count]);
                            }
                            fputs("\",", log_file);

                            //Add necessary comma placeholders

                            fputs("\"N/A\",", log_file);
                            fputs("\"N/A\",", log_file);
                            fputs("\"N/A\",", log_file);
                            fputs("\"N/A\",", log_file);
                            fputs("\"N/A\",", log_file);
                            fputs("\"N/A\"\n", log_file); 

                        }
                        else if(p->payload[0]==UNCONFIRMED_UP || p->payload[0]==CONFIRMED_UP)
                        {
                            //Add AppEUI placeholder
                            fputs("\"N/A\",", log_file); 
                            //Add DEV EUI placeholder
                            fputs("\"N/A\",", log_file); 
                            //Device address
                            fputs("\"", log_file);
                            for(byte_count=0;byte_count<DEVADDR_LEN;byte_count++)
                            {
                                fprintf(log_file, "%02X", p->payload[4-byte_count]);
                            }
                            fputs("\",", log_file);

                            //ADR bit
                            if(p->payload[5]&(1<<7))
                            {
                                fputs("\"Enabled\",", log_file);   
                            }
                            else
                            {
                                fputs("\"Disabled\",", log_file);  
                            }

                            //FOptlen
                            fputs("\"", log_file);
                            fprintf(log_file, "%u", p->payload[5]&0x0F);
                            fputs("\",", log_file);

                            //Fcntr
                            fputs("\"", log_file);    
                            fprintf(log_file, "%u", ((uint16_t)p->payload[7]<<8)+((uint16_t)p->payload[6]));
                            fputs("\",", log_file);

                            //Fport
                            fputs("\"", log_file);
                            fprintf(log_file, "%u", p->payload[(8+(p->payload[5]&0x0F))]);
                            fputs("\",", log_file);

                            if((unsigned)p->payload[(8+(p->payload[5]&0x0F))] == 0U)
                            {
                                fputs("\"MAC command\"\n", log_file);  
                            }
                            else if((unsigned)p->payload[(8+(p->payload[5]&0x0F))] >= 0x01 || p->payload[(8+(p->payload[5]&0x0F))] <= 0xDFU)
                            {
                                fputs("\"Application specific\"\n", log_file);  
                            }
                            else if((unsigned)p->payload[(8+(p->payload[5]&0x0F))] == 0xE0U)
                            {
                                fputs("\"MAC Test protocol\"\n", log_file);  
                            }
                            else
                            {
                                fputs("\"Reserved\"\n", log_file);  
                            }

                        }
                    }
                    // else
                    // {
                    //     //Add all eight field null comma placeholders
                    //     fputs("\"\",", log_file); 
                    //     fputs("\"\",", log_file); 
                    //     fputs("\"\",", log_fisle); 
                    //     fputs("\"\",", log_file); 
                    //     fputs("\"\",", log_file); 
                    //     fputs("\"\",", log_file); 
                    //     fputs("\"\",", log_file);
                    //     fputs("\"\",", log_file);
                    //     fputs("\"\"\n", log_file);
                    // }


                    //

                    /* end of log file line */
                    fflush(log_file);
                    ++pkt_in_log;
                }
            }

            /* check time and rotate log file if necessary */
            ++time_check;
            if (time_check >= 8) {
                time_check = 0;
                time(&now_time);
                if (difftime(now_time, log_start_time) > log_rotate_interval) {
                    fclose(log_file);
                    ESP_LOGI(TAG, "INFO: log file %s closed, %lu packet(s) recorded\n", log_file_name, pkt_in_log);
                    pkt_in_log = 0;
                    open_log();
                }
            }
        }
    }

    ESP_LOGI(TAG, "INFO: Exiting packet logger program\n");
    return;
}
/* --- EOF ------------------------------------------------------------------ */

